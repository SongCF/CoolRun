// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: protocol_message.proto

#ifndef PROTOBUF_protocol_5fmessage_2eproto__INCLUDED
#define PROTOBUF_protocol_5fmessage_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace CoolRun {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_protocol_5fmessage_2eproto();
void protobuf_AssignDesc_protocol_5fmessage_2eproto();
void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

class RegistReq;
class RegistRsp;
class LoginReq;
class LoginRsp;
class AlterInfoReq;
class AlterInfoRsp;
class UnitInfo;
class UpdateInfoReq;
class UpdateInfoRsp;
class ItemInfo;
class AttachInfo;
class MailInfo;
class QueryMailReq;
class QueryMailRsp;
class ReadMailReq;
class ReadMailRsp;
class RankBonusInfo;
class RankUserInfo;
class QueryRankBonusReq;
class QueryRankBonusRsp;
class QueryRankListReq;
class QueryRankListRsp;
class BonusInfo;
class QuerySystemBonusReq;
class QuerySystemBonusRsp;
class GetSystemBonusReq;
class GetSystemBonusRsp;
class GiftBagAttach;
class GiftBagInfo;
class QueryGiftBagReq;
class QueryGiftBagRsp;
class UnifyReq;
class UnifyRsp;
class ReconfigureReq;
class ReconfigureRsp;

enum PlatformType {
  PlatformType_Invalid = 0,
  PlatformType_Common = 1,
  PlatformType_10086_MM = 2,
  PlatformType_10086_JiDi = 3,
  PlatformType_10010_DuanXin = 4,
  PlatformType_10010_KuanDai = 5,
  PlatformType_10010_WO = 6,
  PlatformType_10000_TianYi = 7,
  PlatformType_10000_AiYouXi = 8,
  PlatformType_iTools = 9,
  PlatformType_Kuaiyong = 10,
  PlatformType_PP = 11,
  PlatformType_91 = 12,
  PlatformType_cTalk_IOS = 13,
  PlatformType_cTalk_Android = 14,
  PlatformType_IOS_Appstore = 15
};
bool PlatformType_IsValid(int value);
const PlatformType PlatformType_MIN = PlatformType_Invalid;
const PlatformType PlatformType_MAX = PlatformType_IOS_Appstore;
const int PlatformType_ARRAYSIZE = PlatformType_MAX + 1;

enum MailType {
  MailType_Invalid = 0,
  MailType_Bonus = 1,
  MailType_Notice = 2,
  MailType_Friend = 3
};
bool MailType_IsValid(int value);
const MailType MailType_MIN = MailType_Invalid;
const MailType MailType_MAX = MailType_Friend;
const int MailType_ARRAYSIZE = MailType_MAX + 1;

// ===================================================================

class RegistReq : public ::google::protobuf::MessageLite {
 public:
  RegistReq();
  virtual ~RegistReq();

  RegistReq(const RegistReq& from);

  inline RegistReq& operator=(const RegistReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegistReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegistReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegistReq* other);

  // implements Message ----------------------------------------------

  RegistReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegistReq& from);
  void MergeFrom(const RegistReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CoolRun.PlatformType platform = 1;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 1;
  inline ::CoolRun::PlatformType platform() const;
  inline void set_platform(::CoolRun::PlatformType value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string passwd = 3;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // optional string nickname = 4;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 4;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:CoolRun.RegistReq)
 private:
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_passwd();
  inline void clear_has_passwd();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::std::string* account_;
  ::std::string* passwd_;
  ::std::string* nickname_;
  int platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RegistReq* default_instance_;
};
// -------------------------------------------------------------------

class RegistRsp : public ::google::protobuf::MessageLite {
 public:
  RegistRsp();
  virtual ~RegistRsp();

  RegistRsp(const RegistRsp& from);

  inline RegistRsp& operator=(const RegistRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const RegistRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RegistRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RegistRsp* other);

  // implements Message ----------------------------------------------

  RegistRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RegistRsp& from);
  void MergeFrom(const RegistRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // optional int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.RegistRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::int32 rsp_code_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RegistRsp* default_instance_;
};
// -------------------------------------------------------------------

class LoginReq : public ::google::protobuf::MessageLite {
 public:
  LoginReq();
  virtual ~LoginReq();

  LoginReq(const LoginReq& from);

  inline LoginReq& operator=(const LoginReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginReq* other);

  // implements Message ----------------------------------------------

  LoginReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginReq& from);
  void MergeFrom(const LoginReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.LoginReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static LoginReq* default_instance_;
};
// -------------------------------------------------------------------

class LoginRsp : public ::google::protobuf::MessageLite {
 public:
  LoginRsp();
  virtual ~LoginRsp();

  LoginRsp(const LoginRsp& from);

  inline LoginRsp& operator=(const LoginRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoginRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoginRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoginRsp* other);

  // implements Message ----------------------------------------------

  LoginRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoginRsp& from);
  void MergeFrom(const LoginRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // optional int32 new_mail = 2;
  inline bool has_new_mail() const;
  inline void clear_new_mail();
  static const int kNewMailFieldNumber = 2;
  inline ::google::protobuf::int32 new_mail() const;
  inline void set_new_mail(::google::protobuf::int32 value);

  // optional int32 last_group = 3;
  inline bool has_last_group() const;
  inline void clear_last_group();
  static const int kLastGroupFieldNumber = 3;
  inline ::google::protobuf::int32 last_group() const;
  inline void set_last_group(::google::protobuf::int32 value);

  // optional int32 last_order = 4;
  inline bool has_last_order() const;
  inline void clear_last_order();
  static const int kLastOrderFieldNumber = 4;
  inline ::google::protobuf::int32 last_order() const;
  inline void set_last_order(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.LoginRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();
  inline void set_has_new_mail();
  inline void clear_has_new_mail();
  inline void set_has_last_group();
  inline void clear_has_last_group();
  inline void set_has_last_order();
  inline void clear_has_last_order();

  ::google::protobuf::int32 rsp_code_;
  ::google::protobuf::int32 new_mail_;
  ::google::protobuf::int32 last_group_;
  ::google::protobuf::int32 last_order_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static LoginRsp* default_instance_;
};
// -------------------------------------------------------------------

class AlterInfoReq : public ::google::protobuf::MessageLite {
 public:
  AlterInfoReq();
  virtual ~AlterInfoReq();

  AlterInfoReq(const AlterInfoReq& from);

  inline AlterInfoReq& operator=(const AlterInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const AlterInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AlterInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AlterInfoReq* other);

  // implements Message ----------------------------------------------

  AlterInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AlterInfoReq& from);
  void MergeFrom(const AlterInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // optional string nickname = 2;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 2;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // @@protoc_insertion_point(class_scope:CoolRun.AlterInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_nickname();
  inline void clear_has_nickname();

  ::std::string* nickname_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static AlterInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class AlterInfoRsp : public ::google::protobuf::MessageLite {
 public:
  AlterInfoRsp();
  virtual ~AlterInfoRsp();

  AlterInfoRsp(const AlterInfoRsp& from);

  inline AlterInfoRsp& operator=(const AlterInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const AlterInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AlterInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AlterInfoRsp* other);

  // implements Message ----------------------------------------------

  AlterInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AlterInfoRsp& from);
  void MergeFrom(const AlterInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.AlterInfoRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static AlterInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class UnitInfo : public ::google::protobuf::MessageLite {
 public:
  UnitInfo();
  virtual ~UnitInfo();

  UnitInfo(const UnitInfo& from);

  inline UnitInfo& operator=(const UnitInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const UnitInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnitInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnitInfo* other);

  // implements Message ----------------------------------------------

  UnitInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnitInfo& from);
  void MergeFrom(const UnitInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required bool is_activate = 2;
  inline bool has_is_activate() const;
  inline void clear_is_activate();
  static const int kIsActivateFieldNumber = 2;
  inline bool is_activate() const;
  inline void set_is_activate(bool value);

  // required bool is_use = 3;
  inline bool has_is_use() const;
  inline void clear_is_use();
  static const int kIsUseFieldNumber = 3;
  inline bool is_use() const;
  inline void set_is_use(bool value);

  // optional int32 level = 4;
  inline bool has_level() const;
  inline void clear_level();
  static const int kLevelFieldNumber = 4;
  inline ::google::protobuf::int32 level() const;
  inline void set_level(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.UnitInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_is_activate();
  inline void clear_has_is_activate();
  inline void set_has_is_use();
  inline void clear_has_is_use();
  inline void set_has_level();
  inline void clear_has_level();

  ::google::protobuf::int32 type_;
  bool is_activate_;
  bool is_use_;
  ::google::protobuf::int32 level_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UnitInfo* default_instance_;
};
// -------------------------------------------------------------------

class UpdateInfoReq : public ::google::protobuf::MessageLite {
 public:
  UpdateInfoReq();
  virtual ~UpdateInfoReq();

  UpdateInfoReq(const UpdateInfoReq& from);

  inline UpdateInfoReq& operator=(const UpdateInfoReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateInfoReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateInfoReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateInfoReq* other);

  // implements Message ----------------------------------------------

  UpdateInfoReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateInfoReq& from);
  void MergeFrom(const UpdateInfoReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 score = 2;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 2;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // required int32 distance = 3;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 3;
  inline ::google::protobuf::int32 distance() const;
  inline void set_distance(::google::protobuf::int32 value);

  // repeated .CoolRun.UnitInfo actor = 4;
  inline int actor_size() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 4;
  inline const ::CoolRun::UnitInfo& actor(int index) const;
  inline ::CoolRun::UnitInfo* mutable_actor(int index);
  inline ::CoolRun::UnitInfo* add_actor();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >&
      actor() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >*
      mutable_actor();

  // repeated .CoolRun.UnitInfo pet = 5;
  inline int pet_size() const;
  inline void clear_pet();
  static const int kPetFieldNumber = 5;
  inline const ::CoolRun::UnitInfo& pet(int index) const;
  inline ::CoolRun::UnitInfo* mutable_pet(int index);
  inline ::CoolRun::UnitInfo* add_pet();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >&
      pet() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >*
      mutable_pet();

  // repeated .CoolRun.UnitInfo magic = 6;
  inline int magic_size() const;
  inline void clear_magic();
  static const int kMagicFieldNumber = 6;
  inline const ::CoolRun::UnitInfo& magic(int index) const;
  inline ::CoolRun::UnitInfo* mutable_magic(int index);
  inline ::CoolRun::UnitInfo* add_magic();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >&
      magic() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >*
      mutable_magic();

  // @@protoc_insertion_point(class_scope:CoolRun.UpdateInfoReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_distance();
  inline void clear_has_distance();

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo > actor_;
  ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo > pet_;
  ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo > magic_;
  ::google::protobuf::int32 distance_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UpdateInfoReq* default_instance_;
};
// -------------------------------------------------------------------

class UpdateInfoRsp : public ::google::protobuf::MessageLite {
 public:
  UpdateInfoRsp();
  virtual ~UpdateInfoRsp();

  UpdateInfoRsp(const UpdateInfoRsp& from);

  inline UpdateInfoRsp& operator=(const UpdateInfoRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UpdateInfoRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UpdateInfoRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UpdateInfoRsp* other);

  // implements Message ----------------------------------------------

  UpdateInfoRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UpdateInfoRsp& from);
  void MergeFrom(const UpdateInfoRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.UpdateInfoRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UpdateInfoRsp* default_instance_;
};
// -------------------------------------------------------------------

class ItemInfo : public ::google::protobuf::MessageLite {
 public:
  ItemInfo();
  virtual ~ItemInfo();

  ItemInfo(const ItemInfo& from);

  inline ItemInfo& operator=(const ItemInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const ItemInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ItemInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ItemInfo* other);

  // implements Message ----------------------------------------------

  ItemInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ItemInfo& from);
  void MergeFrom(const ItemInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // required int32 count = 2;
  inline bool has_count() const;
  inline void clear_count();
  static const int kCountFieldNumber = 2;
  inline ::google::protobuf::int32 count() const;
  inline void set_count(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.ItemInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_count();
  inline void clear_has_count();

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 count_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ItemInfo* default_instance_;
};
// -------------------------------------------------------------------

class AttachInfo : public ::google::protobuf::MessageLite {
 public:
  AttachInfo();
  virtual ~AttachInfo();

  AttachInfo(const AttachInfo& from);

  inline AttachInfo& operator=(const AttachInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const AttachInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const AttachInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(AttachInfo* other);

  // implements Message ----------------------------------------------

  AttachInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const AttachInfo& from);
  void MergeFrom(const AttachInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .CoolRun.ItemInfo item = 1;
  inline int item_size() const;
  inline void clear_item();
  static const int kItemFieldNumber = 1;
  inline const ::CoolRun::ItemInfo& item(int index) const;
  inline ::CoolRun::ItemInfo* mutable_item(int index);
  inline ::CoolRun::ItemInfo* add_item();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::ItemInfo >&
      item() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::ItemInfo >*
      mutable_item();

  // optional int32 vitality = 2;
  inline bool has_vitality() const;
  inline void clear_vitality();
  static const int kVitalityFieldNumber = 2;
  inline ::google::protobuf::int32 vitality() const;
  inline void set_vitality(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.AttachInfo)
 private:
  inline void set_has_vitality();
  inline void clear_has_vitality();

  ::google::protobuf::RepeatedPtrField< ::CoolRun::ItemInfo > item_;
  ::google::protobuf::int32 vitality_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static AttachInfo* default_instance_;
};
// -------------------------------------------------------------------

class MailInfo : public ::google::protobuf::MessageLite {
 public:
  MailInfo();
  virtual ~MailInfo();

  MailInfo(const MailInfo& from);

  inline MailInfo& operator=(const MailInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const MailInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const MailInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(MailInfo* other);

  // implements Message ----------------------------------------------

  MailInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const MailInfo& from);
  void MergeFrom(const MailInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CoolRun.MailType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::CoolRun::MailType type() const;
  inline void set_type(::CoolRun::MailType value);

  // required bool is_read = 2;
  inline bool has_is_read() const;
  inline void clear_is_read();
  static const int kIsReadFieldNumber = 2;
  inline bool is_read() const;
  inline void set_is_read(bool value);

  // required int32 id = 3;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 3;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required int32 addresser_id = 4;
  inline bool has_addresser_id() const;
  inline void clear_addresser_id();
  static const int kAddresserIdFieldNumber = 4;
  inline ::google::protobuf::int32 addresser_id() const;
  inline void set_addresser_id(::google::protobuf::int32 value);

  // optional .CoolRun.AttachInfo attach = 5;
  inline bool has_attach() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 5;
  inline const ::CoolRun::AttachInfo& attach() const;
  inline ::CoolRun::AttachInfo* mutable_attach();
  inline ::CoolRun::AttachInfo* release_attach();
  inline void set_allocated_attach(::CoolRun::AttachInfo* attach);

  // optional string addresser = 6;
  inline bool has_addresser() const;
  inline void clear_addresser();
  static const int kAddresserFieldNumber = 6;
  inline const ::std::string& addresser() const;
  inline void set_addresser(const ::std::string& value);
  inline void set_addresser(const char* value);
  inline void set_addresser(const char* value, size_t size);
  inline ::std::string* mutable_addresser();
  inline ::std::string* release_addresser();
  inline void set_allocated_addresser(::std::string* addresser);

  // optional string content = 7;
  inline bool has_content() const;
  inline void clear_content();
  static const int kContentFieldNumber = 7;
  inline const ::std::string& content() const;
  inline void set_content(const ::std::string& value);
  inline void set_content(const char* value);
  inline void set_content(const char* value, size_t size);
  inline ::std::string* mutable_content();
  inline ::std::string* release_content();
  inline void set_allocated_content(::std::string* content);

  // @@protoc_insertion_point(class_scope:CoolRun.MailInfo)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_is_read();
  inline void clear_has_is_read();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_addresser_id();
  inline void clear_has_addresser_id();
  inline void set_has_attach();
  inline void clear_has_attach();
  inline void set_has_addresser();
  inline void clear_has_addresser();
  inline void set_has_content();
  inline void clear_has_content();

  int type_;
  bool is_read_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 addresser_id_;
  ::CoolRun::AttachInfo* attach_;
  ::std::string* addresser_;
  ::std::string* content_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(7 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static MailInfo* default_instance_;
};
// -------------------------------------------------------------------

class QueryMailReq : public ::google::protobuf::MessageLite {
 public:
  QueryMailReq();
  virtual ~QueryMailReq();

  QueryMailReq(const QueryMailReq& from);

  inline QueryMailReq& operator=(const QueryMailReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryMailReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryMailReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryMailReq* other);

  // implements Message ----------------------------------------------

  QueryMailReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryMailReq& from);
  void MergeFrom(const QueryMailReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.QueryMailReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QueryMailReq* default_instance_;
};
// -------------------------------------------------------------------

class QueryMailRsp : public ::google::protobuf::MessageLite {
 public:
  QueryMailRsp();
  virtual ~QueryMailRsp();

  QueryMailRsp(const QueryMailRsp& from);

  inline QueryMailRsp& operator=(const QueryMailRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryMailRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryMailRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryMailRsp* other);

  // implements Message ----------------------------------------------

  QueryMailRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryMailRsp& from);
  void MergeFrom(const QueryMailRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // repeated .CoolRun.MailInfo email = 2;
  inline int email_size() const;
  inline void clear_email();
  static const int kEmailFieldNumber = 2;
  inline const ::CoolRun::MailInfo& email(int index) const;
  inline ::CoolRun::MailInfo* mutable_email(int index);
  inline ::CoolRun::MailInfo* add_email();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::MailInfo >&
      email() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::MailInfo >*
      mutable_email();

  // @@protoc_insertion_point(class_scope:CoolRun.QueryMailRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::RepeatedPtrField< ::CoolRun::MailInfo > email_;
  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QueryMailRsp* default_instance_;
};
// -------------------------------------------------------------------

class ReadMailReq : public ::google::protobuf::MessageLite {
 public:
  ReadMailReq();
  virtual ~ReadMailReq();

  ReadMailReq(const ReadMailReq& from);

  inline ReadMailReq& operator=(const ReadMailReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReadMailReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadMailReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadMailReq* other);

  // implements Message ----------------------------------------------

  ReadMailReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadMailReq& from);
  void MergeFrom(const ReadMailReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.ReadMailReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ReadMailReq* default_instance_;
};
// -------------------------------------------------------------------

class ReadMailRsp : public ::google::protobuf::MessageLite {
 public:
  ReadMailRsp();
  virtual ~ReadMailRsp();

  ReadMailRsp(const ReadMailRsp& from);

  inline ReadMailRsp& operator=(const ReadMailRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReadMailRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReadMailRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReadMailRsp* other);

  // implements Message ----------------------------------------------

  ReadMailRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReadMailRsp& from);
  void MergeFrom(const ReadMailRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.ReadMailRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ReadMailRsp* default_instance_;
};
// -------------------------------------------------------------------

class RankBonusInfo : public ::google::protobuf::MessageLite {
 public:
  RankBonusInfo();
  virtual ~RankBonusInfo();

  RankBonusInfo(const RankBonusInfo& from);

  inline RankBonusInfo& operator=(const RankBonusInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RankBonusInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RankBonusInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RankBonusInfo* other);

  // implements Message ----------------------------------------------

  RankBonusInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RankBonusInfo& from);
  void MergeFrom(const RankBonusInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional int32 group_id = 2;
  inline bool has_group_id() const;
  inline void clear_group_id();
  static const int kGroupIdFieldNumber = 2;
  inline ::google::protobuf::int32 group_id() const;
  inline void set_group_id(::google::protobuf::int32 value);

  // optional string group_name = 3;
  inline bool has_group_name() const;
  inline void clear_group_name();
  static const int kGroupNameFieldNumber = 3;
  inline const ::std::string& group_name() const;
  inline void set_group_name(const ::std::string& value);
  inline void set_group_name(const char* value);
  inline void set_group_name(const char* value, size_t size);
  inline ::std::string* mutable_group_name();
  inline ::std::string* release_group_name();
  inline void set_allocated_group_name(::std::string* group_name);

  // optional int32 bonus_id = 4;
  inline bool has_bonus_id() const;
  inline void clear_bonus_id();
  static const int kBonusIdFieldNumber = 4;
  inline ::google::protobuf::int32 bonus_id() const;
  inline void set_bonus_id(::google::protobuf::int32 value);

  // optional .CoolRun.AttachInfo attach = 5;
  inline bool has_attach() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 5;
  inline const ::CoolRun::AttachInfo& attach() const;
  inline ::CoolRun::AttachInfo* mutable_attach();
  inline ::CoolRun::AttachInfo* release_attach();
  inline void set_allocated_attach(::CoolRun::AttachInfo* attach);

  // @@protoc_insertion_point(class_scope:CoolRun.RankBonusInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_group_id();
  inline void clear_has_group_id();
  inline void set_has_group_name();
  inline void clear_has_group_name();
  inline void set_has_bonus_id();
  inline void clear_has_bonus_id();
  inline void set_has_attach();
  inline void clear_has_attach();

  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 group_id_;
  ::std::string* group_name_;
  ::CoolRun::AttachInfo* attach_;
  ::google::protobuf::int32 bonus_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RankBonusInfo* default_instance_;
};
// -------------------------------------------------------------------

class RankUserInfo : public ::google::protobuf::MessageLite {
 public:
  RankUserInfo();
  virtual ~RankUserInfo();

  RankUserInfo(const RankUserInfo& from);

  inline RankUserInfo& operator=(const RankUserInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const RankUserInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const RankUserInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(RankUserInfo* other);

  // implements Message ----------------------------------------------

  RankUserInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const RankUserInfo& from);
  void MergeFrom(const RankUserInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 user_order = 2;
  inline bool has_user_order() const;
  inline void clear_user_order();
  static const int kUserOrderFieldNumber = 2;
  inline ::google::protobuf::int32 user_order() const;
  inline void set_user_order(::google::protobuf::int32 value);

  // required int32 score = 3;
  inline bool has_score() const;
  inline void clear_score();
  static const int kScoreFieldNumber = 3;
  inline ::google::protobuf::int32 score() const;
  inline void set_score(::google::protobuf::int32 value);

  // required int32 distance = 4;
  inline bool has_distance() const;
  inline void clear_distance();
  static const int kDistanceFieldNumber = 4;
  inline ::google::protobuf::int32 distance() const;
  inline void set_distance(::google::protobuf::int32 value);

  // required .CoolRun.UnitInfo actor = 5;
  inline bool has_actor() const;
  inline void clear_actor();
  static const int kActorFieldNumber = 5;
  inline const ::CoolRun::UnitInfo& actor() const;
  inline ::CoolRun::UnitInfo* mutable_actor();
  inline ::CoolRun::UnitInfo* release_actor();
  inline void set_allocated_actor(::CoolRun::UnitInfo* actor);

  // optional .CoolRun.UnitInfo pet = 6;
  inline bool has_pet() const;
  inline void clear_pet();
  static const int kPetFieldNumber = 6;
  inline const ::CoolRun::UnitInfo& pet() const;
  inline ::CoolRun::UnitInfo* mutable_pet();
  inline ::CoolRun::UnitInfo* release_pet();
  inline void set_allocated_pet(::CoolRun::UnitInfo* pet);

  // optional .CoolRun.UnitInfo magic = 7;
  inline bool has_magic() const;
  inline void clear_magic();
  static const int kMagicFieldNumber = 7;
  inline const ::CoolRun::UnitInfo& magic() const;
  inline ::CoolRun::UnitInfo* mutable_magic();
  inline ::CoolRun::UnitInfo* release_magic();
  inline void set_allocated_magic(::CoolRun::UnitInfo* magic);

  // optional string user_name = 8;
  inline bool has_user_name() const;
  inline void clear_user_name();
  static const int kUserNameFieldNumber = 8;
  inline const ::std::string& user_name() const;
  inline void set_user_name(const ::std::string& value);
  inline void set_user_name(const char* value);
  inline void set_user_name(const char* value, size_t size);
  inline ::std::string* mutable_user_name();
  inline ::std::string* release_user_name();
  inline void set_allocated_user_name(::std::string* user_name);

  // @@protoc_insertion_point(class_scope:CoolRun.RankUserInfo)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_user_order();
  inline void clear_has_user_order();
  inline void set_has_score();
  inline void clear_has_score();
  inline void set_has_distance();
  inline void clear_has_distance();
  inline void set_has_actor();
  inline void clear_has_actor();
  inline void set_has_pet();
  inline void clear_has_pet();
  inline void set_has_magic();
  inline void clear_has_magic();
  inline void set_has_user_name();
  inline void clear_has_user_name();

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 user_order_;
  ::google::protobuf::int32 score_;
  ::google::protobuf::int32 distance_;
  ::CoolRun::UnitInfo* actor_;
  ::CoolRun::UnitInfo* pet_;
  ::CoolRun::UnitInfo* magic_;
  ::std::string* user_name_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static RankUserInfo* default_instance_;
};
// -------------------------------------------------------------------

class QueryRankBonusReq : public ::google::protobuf::MessageLite {
 public:
  QueryRankBonusReq();
  virtual ~QueryRankBonusReq();

  QueryRankBonusReq(const QueryRankBonusReq& from);

  inline QueryRankBonusReq& operator=(const QueryRankBonusReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryRankBonusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryRankBonusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryRankBonusReq* other);

  // implements Message ----------------------------------------------

  QueryRankBonusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryRankBonusReq& from);
  void MergeFrom(const QueryRankBonusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 stub = 1;
  inline bool has_stub() const;
  inline void clear_stub();
  static const int kStubFieldNumber = 1;
  inline ::google::protobuf::int32 stub() const;
  inline void set_stub(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.QueryRankBonusReq)
 private:
  inline void set_has_stub();
  inline void clear_has_stub();

  ::google::protobuf::int32 stub_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QueryRankBonusReq* default_instance_;
};
// -------------------------------------------------------------------

class QueryRankBonusRsp : public ::google::protobuf::MessageLite {
 public:
  QueryRankBonusRsp();
  virtual ~QueryRankBonusRsp();

  QueryRankBonusRsp(const QueryRankBonusRsp& from);

  inline QueryRankBonusRsp& operator=(const QueryRankBonusRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryRankBonusRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryRankBonusRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryRankBonusRsp* other);

  // implements Message ----------------------------------------------

  QueryRankBonusRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryRankBonusRsp& from);
  void MergeFrom(const QueryRankBonusRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // repeated .CoolRun.RankBonusInfo bonus = 2;
  inline int bonus_size() const;
  inline void clear_bonus();
  static const int kBonusFieldNumber = 2;
  inline const ::CoolRun::RankBonusInfo& bonus(int index) const;
  inline ::CoolRun::RankBonusInfo* mutable_bonus(int index);
  inline ::CoolRun::RankBonusInfo* add_bonus();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::RankBonusInfo >&
      bonus() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::RankBonusInfo >*
      mutable_bonus();

  // @@protoc_insertion_point(class_scope:CoolRun.QueryRankBonusRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::RepeatedPtrField< ::CoolRun::RankBonusInfo > bonus_;
  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QueryRankBonusRsp* default_instance_;
};
// -------------------------------------------------------------------

class QueryRankListReq : public ::google::protobuf::MessageLite {
 public:
  QueryRankListReq();
  virtual ~QueryRankListReq();

  QueryRankListReq(const QueryRankListReq& from);

  inline QueryRankListReq& operator=(const QueryRankListReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryRankListReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryRankListReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryRankListReq* other);

  // implements Message ----------------------------------------------

  QueryRankListReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryRankListReq& from);
  void MergeFrom(const QueryRankListReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.QueryRankListReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QueryRankListReq* default_instance_;
};
// -------------------------------------------------------------------

class QueryRankListRsp : public ::google::protobuf::MessageLite {
 public:
  QueryRankListRsp();
  virtual ~QueryRankListRsp();

  QueryRankListRsp(const QueryRankListRsp& from);

  inline QueryRankListRsp& operator=(const QueryRankListRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryRankListRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryRankListRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryRankListRsp* other);

  // implements Message ----------------------------------------------

  QueryRankListRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryRankListRsp& from);
  void MergeFrom(const QueryRankListRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // repeated .CoolRun.RankUserInfo user_list = 2;
  inline int user_list_size() const;
  inline void clear_user_list();
  static const int kUserListFieldNumber = 2;
  inline const ::CoolRun::RankUserInfo& user_list(int index) const;
  inline ::CoolRun::RankUserInfo* mutable_user_list(int index);
  inline ::CoolRun::RankUserInfo* add_user_list();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::RankUserInfo >&
      user_list() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::RankUserInfo >*
      mutable_user_list();

  // optional int32 cur_group = 3;
  inline bool has_cur_group() const;
  inline void clear_cur_group();
  static const int kCurGroupFieldNumber = 3;
  inline ::google::protobuf::int32 cur_group() const;
  inline void set_cur_group(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.QueryRankListRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();
  inline void set_has_cur_group();
  inline void clear_has_cur_group();

  ::google::protobuf::RepeatedPtrField< ::CoolRun::RankUserInfo > user_list_;
  ::google::protobuf::int32 rsp_code_;
  ::google::protobuf::int32 cur_group_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QueryRankListRsp* default_instance_;
};
// -------------------------------------------------------------------

class BonusInfo : public ::google::protobuf::MessageLite {
 public:
  BonusInfo();
  virtual ~BonusInfo();

  BonusInfo(const BonusInfo& from);

  inline BonusInfo& operator=(const BonusInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const BonusInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const BonusInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(BonusInfo* other);

  // implements Message ----------------------------------------------

  BonusInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const BonusInfo& from);
  void MergeFrom(const BonusInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required bool is_get = 2;
  inline bool has_is_get() const;
  inline void clear_is_get();
  static const int kIsGetFieldNumber = 2;
  inline bool is_get() const;
  inline void set_is_get(bool value);

  // required bool enable = 3;
  inline bool has_enable() const;
  inline void clear_enable();
  static const int kEnableFieldNumber = 3;
  inline bool enable() const;
  inline void set_enable(bool value);

  // optional .CoolRun.AttachInfo attach = 4;
  inline bool has_attach() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 4;
  inline const ::CoolRun::AttachInfo& attach() const;
  inline ::CoolRun::AttachInfo* mutable_attach();
  inline ::CoolRun::AttachInfo* release_attach();
  inline void set_allocated_attach(::CoolRun::AttachInfo* attach);

  // @@protoc_insertion_point(class_scope:CoolRun.BonusInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_is_get();
  inline void clear_has_is_get();
  inline void set_has_enable();
  inline void clear_has_enable();
  inline void set_has_attach();
  inline void clear_has_attach();

  ::google::protobuf::int32 id_;
  bool is_get_;
  bool enable_;
  ::CoolRun::AttachInfo* attach_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static BonusInfo* default_instance_;
};
// -------------------------------------------------------------------

class QuerySystemBonusReq : public ::google::protobuf::MessageLite {
 public:
  QuerySystemBonusReq();
  virtual ~QuerySystemBonusReq();

  QuerySystemBonusReq(const QuerySystemBonusReq& from);

  inline QuerySystemBonusReq& operator=(const QuerySystemBonusReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const QuerySystemBonusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuerySystemBonusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuerySystemBonusReq* other);

  // implements Message ----------------------------------------------

  QuerySystemBonusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuerySystemBonusReq& from);
  void MergeFrom(const QuerySystemBonusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.QuerySystemBonusReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QuerySystemBonusReq* default_instance_;
};
// -------------------------------------------------------------------

class QuerySystemBonusRsp : public ::google::protobuf::MessageLite {
 public:
  QuerySystemBonusRsp();
  virtual ~QuerySystemBonusRsp();

  QuerySystemBonusRsp(const QuerySystemBonusRsp& from);

  inline QuerySystemBonusRsp& operator=(const QuerySystemBonusRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const QuerySystemBonusRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QuerySystemBonusRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QuerySystemBonusRsp* other);

  // implements Message ----------------------------------------------

  QuerySystemBonusRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QuerySystemBonusRsp& from);
  void MergeFrom(const QuerySystemBonusRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // repeated .CoolRun.BonusInfo bonus = 2;
  inline int bonus_size() const;
  inline void clear_bonus();
  static const int kBonusFieldNumber = 2;
  inline const ::CoolRun::BonusInfo& bonus(int index) const;
  inline ::CoolRun::BonusInfo* mutable_bonus(int index);
  inline ::CoolRun::BonusInfo* add_bonus();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::BonusInfo >&
      bonus() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::BonusInfo >*
      mutable_bonus();

  // @@protoc_insertion_point(class_scope:CoolRun.QuerySystemBonusRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::RepeatedPtrField< ::CoolRun::BonusInfo > bonus_;
  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QuerySystemBonusRsp* default_instance_;
};
// -------------------------------------------------------------------

class GetSystemBonusReq : public ::google::protobuf::MessageLite {
 public:
  GetSystemBonusReq();
  virtual ~GetSystemBonusReq();

  GetSystemBonusReq(const GetSystemBonusReq& from);

  inline GetSystemBonusReq& operator=(const GetSystemBonusReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetSystemBonusReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetSystemBonusReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetSystemBonusReq* other);

  // implements Message ----------------------------------------------

  GetSystemBonusReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetSystemBonusReq& from);
  void MergeFrom(const GetSystemBonusReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 user_id = 1;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 1;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // required int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.GetSystemBonusReq)
 private:
  inline void set_has_user_id();
  inline void clear_has_user_id();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::int32 user_id_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetSystemBonusReq* default_instance_;
};
// -------------------------------------------------------------------

class GetSystemBonusRsp : public ::google::protobuf::MessageLite {
 public:
  GetSystemBonusRsp();
  virtual ~GetSystemBonusRsp();

  GetSystemBonusRsp(const GetSystemBonusRsp& from);

  inline GetSystemBonusRsp& operator=(const GetSystemBonusRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const GetSystemBonusRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GetSystemBonusRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GetSystemBonusRsp* other);

  // implements Message ----------------------------------------------

  GetSystemBonusRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GetSystemBonusRsp& from);
  void MergeFrom(const GetSystemBonusRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.GetSystemBonusRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GetSystemBonusRsp* default_instance_;
};
// -------------------------------------------------------------------

class GiftBagAttach : public ::google::protobuf::MessageLite {
 public:
  GiftBagAttach();
  virtual ~GiftBagAttach();

  GiftBagAttach(const GiftBagAttach& from);

  inline GiftBagAttach& operator=(const GiftBagAttach& from) {
    CopyFrom(from);
    return *this;
  }

  static const GiftBagAttach& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiftBagAttach* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiftBagAttach* other);

  // implements Message ----------------------------------------------

  GiftBagAttach* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiftBagAttach& from);
  void MergeFrom(const GiftBagAttach& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 weight = 1;
  inline bool has_weight() const;
  inline void clear_weight();
  static const int kWeightFieldNumber = 1;
  inline ::google::protobuf::int32 weight() const;
  inline void set_weight(::google::protobuf::int32 value);

  // optional .CoolRun.AttachInfo attach = 2;
  inline bool has_attach() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 2;
  inline const ::CoolRun::AttachInfo& attach() const;
  inline ::CoolRun::AttachInfo* mutable_attach();
  inline ::CoolRun::AttachInfo* release_attach();
  inline void set_allocated_attach(::CoolRun::AttachInfo* attach);

  // @@protoc_insertion_point(class_scope:CoolRun.GiftBagAttach)
 private:
  inline void set_has_weight();
  inline void clear_has_weight();
  inline void set_has_attach();
  inline void clear_has_attach();

  ::CoolRun::AttachInfo* attach_;
  ::google::protobuf::int32 weight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GiftBagAttach* default_instance_;
};
// -------------------------------------------------------------------

class GiftBagInfo : public ::google::protobuf::MessageLite {
 public:
  GiftBagInfo();
  virtual ~GiftBagInfo();

  GiftBagInfo(const GiftBagInfo& from);

  inline GiftBagInfo& operator=(const GiftBagInfo& from) {
    CopyFrom(from);
    return *this;
  }

  static const GiftBagInfo& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const GiftBagInfo* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(GiftBagInfo* other);

  // implements Message ----------------------------------------------

  GiftBagInfo* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const GiftBagInfo& from);
  void MergeFrom(const GiftBagInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required bool is_random = 2;
  inline bool has_is_random() const;
  inline void clear_is_random();
  static const int kIsRandomFieldNumber = 2;
  inline bool is_random() const;
  inline void set_is_random(bool value);

  // repeated .CoolRun.GiftBagAttach attach = 3;
  inline int attach_size() const;
  inline void clear_attach();
  static const int kAttachFieldNumber = 3;
  inline const ::CoolRun::GiftBagAttach& attach(int index) const;
  inline ::CoolRun::GiftBagAttach* mutable_attach(int index);
  inline ::CoolRun::GiftBagAttach* add_attach();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagAttach >&
      attach() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagAttach >*
      mutable_attach();

  // @@protoc_insertion_point(class_scope:CoolRun.GiftBagInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_is_random();
  inline void clear_has_is_random();

  ::google::protobuf::int32 id_;
  bool is_random_;
  ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagAttach > attach_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static GiftBagInfo* default_instance_;
};
// -------------------------------------------------------------------

class QueryGiftBagReq : public ::google::protobuf::MessageLite {
 public:
  QueryGiftBagReq();
  virtual ~QueryGiftBagReq();

  QueryGiftBagReq(const QueryGiftBagReq& from);

  inline QueryGiftBagReq& operator=(const QueryGiftBagReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryGiftBagReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryGiftBagReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryGiftBagReq* other);

  // implements Message ----------------------------------------------

  QueryGiftBagReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryGiftBagReq& from);
  void MergeFrom(const QueryGiftBagReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:CoolRun.QueryGiftBagReq)
 private:
  inline void set_has_version();
  inline void clear_has_version();

  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QueryGiftBagReq* default_instance_;
};
// -------------------------------------------------------------------

class QueryGiftBagRsp : public ::google::protobuf::MessageLite {
 public:
  QueryGiftBagRsp();
  virtual ~QueryGiftBagRsp();

  QueryGiftBagRsp(const QueryGiftBagRsp& from);

  inline QueryGiftBagRsp& operator=(const QueryGiftBagRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const QueryGiftBagRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const QueryGiftBagRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(QueryGiftBagRsp* other);

  // implements Message ----------------------------------------------

  QueryGiftBagRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const QueryGiftBagRsp& from);
  void MergeFrom(const QueryGiftBagRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // repeated .CoolRun.GiftBagInfo gift_bag = 2;
  inline int gift_bag_size() const;
  inline void clear_gift_bag();
  static const int kGiftBagFieldNumber = 2;
  inline const ::CoolRun::GiftBagInfo& gift_bag(int index) const;
  inline ::CoolRun::GiftBagInfo* mutable_gift_bag(int index);
  inline ::CoolRun::GiftBagInfo* add_gift_bag();
  inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagInfo >&
      gift_bag() const;
  inline ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagInfo >*
      mutable_gift_bag();

  // optional bool is_update = 3;
  inline bool has_is_update() const;
  inline void clear_is_update();
  static const int kIsUpdateFieldNumber = 3;
  inline bool is_update() const;
  inline void set_is_update(bool value);

  // optional string version = 4;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 4;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // @@protoc_insertion_point(class_scope:CoolRun.QueryGiftBagRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();
  inline void set_has_is_update();
  inline void clear_has_is_update();
  inline void set_has_version();
  inline void clear_has_version();

  ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagInfo > gift_bag_;
  ::google::protobuf::int32 rsp_code_;
  bool is_update_;
  ::std::string* version_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static QueryGiftBagRsp* default_instance_;
};
// -------------------------------------------------------------------

class UnifyReq : public ::google::protobuf::MessageLite {
 public:
  UnifyReq();
  virtual ~UnifyReq();

  UnifyReq(const UnifyReq& from);

  inline UnifyReq& operator=(const UnifyReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const UnifyReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnifyReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnifyReq* other);

  // implements Message ----------------------------------------------

  UnifyReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnifyReq& from);
  void MergeFrom(const UnifyReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .CoolRun.PlatformType platform = 1;
  inline bool has_platform() const;
  inline void clear_platform();
  static const int kPlatformFieldNumber = 1;
  inline ::CoolRun::PlatformType platform() const;
  inline void set_platform(::CoolRun::PlatformType value);

  // optional string account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::std::string& account() const;
  inline void set_account(const ::std::string& value);
  inline void set_account(const char* value);
  inline void set_account(const char* value, size_t size);
  inline ::std::string* mutable_account();
  inline ::std::string* release_account();
  inline void set_allocated_account(::std::string* account);

  // optional string passwd = 3;
  inline bool has_passwd() const;
  inline void clear_passwd();
  static const int kPasswdFieldNumber = 3;
  inline const ::std::string& passwd() const;
  inline void set_passwd(const ::std::string& value);
  inline void set_passwd(const char* value);
  inline void set_passwd(const char* value, size_t size);
  inline ::std::string* mutable_passwd();
  inline ::std::string* release_passwd();
  inline void set_allocated_passwd(::std::string* passwd);

  // @@protoc_insertion_point(class_scope:CoolRun.UnifyReq)
 private:
  inline void set_has_platform();
  inline void clear_has_platform();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_passwd();
  inline void clear_has_passwd();

  ::std::string* account_;
  ::std::string* passwd_;
  int platform_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UnifyReq* default_instance_;
};
// -------------------------------------------------------------------

class UnifyRsp : public ::google::protobuf::MessageLite {
 public:
  UnifyRsp();
  virtual ~UnifyRsp();

  UnifyRsp(const UnifyRsp& from);

  inline UnifyRsp& operator=(const UnifyRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const UnifyRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const UnifyRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(UnifyRsp* other);

  // implements Message ----------------------------------------------

  UnifyRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const UnifyRsp& from);
  void MergeFrom(const UnifyRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // optional int32 user_id = 2;
  inline bool has_user_id() const;
  inline void clear_user_id();
  static const int kUserIdFieldNumber = 2;
  inline ::google::protobuf::int32 user_id() const;
  inline void set_user_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.UnifyRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();
  inline void set_has_user_id();
  inline void clear_has_user_id();

  ::google::protobuf::int32 rsp_code_;
  ::google::protobuf::int32 user_id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static UnifyRsp* default_instance_;
};
// -------------------------------------------------------------------

class ReconfigureReq : public ::google::protobuf::MessageLite {
 public:
  ReconfigureReq();
  virtual ~ReconfigureReq();

  ReconfigureReq(const ReconfigureReq& from);

  inline ReconfigureReq& operator=(const ReconfigureReq& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReconfigureReq& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReconfigureReq* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReconfigureReq* other);

  // implements Message ----------------------------------------------

  ReconfigureReq* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReconfigureReq& from);
  void MergeFrom(const ReconfigureReq& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.ReconfigureReq)
 private:
  inline void set_has_type();
  inline void clear_has_type();

  ::google::protobuf::int32 type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ReconfigureReq* default_instance_;
};
// -------------------------------------------------------------------

class ReconfigureRsp : public ::google::protobuf::MessageLite {
 public:
  ReconfigureRsp();
  virtual ~ReconfigureRsp();

  ReconfigureRsp(const ReconfigureRsp& from);

  inline ReconfigureRsp& operator=(const ReconfigureRsp& from) {
    CopyFrom(from);
    return *this;
  }

  static const ReconfigureRsp& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ReconfigureRsp* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ReconfigureRsp* other);

  // implements Message ----------------------------------------------

  ReconfigureRsp* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ReconfigureRsp& from);
  void MergeFrom(const ReconfigureRsp& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 rsp_code = 1;
  inline bool has_rsp_code() const;
  inline void clear_rsp_code();
  static const int kRspCodeFieldNumber = 1;
  inline ::google::protobuf::int32 rsp_code() const;
  inline void set_rsp_code(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:CoolRun.ReconfigureRsp)
 private:
  inline void set_has_rsp_code();
  inline void clear_has_rsp_code();

  ::google::protobuf::int32 rsp_code_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_protocol_5fmessage_2eproto();
  #endif
  friend void protobuf_AssignDesc_protocol_5fmessage_2eproto();
  friend void protobuf_ShutdownFile_protocol_5fmessage_2eproto();

  void InitAsDefaultInstance();
  static ReconfigureRsp* default_instance_;
};
// ===================================================================


// ===================================================================

// RegistReq

// required .CoolRun.PlatformType platform = 1;
inline bool RegistReq::has_platform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistReq::set_has_platform() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistReq::clear_has_platform() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistReq::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::CoolRun::PlatformType RegistReq::platform() const {
  return static_cast< ::CoolRun::PlatformType >(platform_);
}
inline void RegistReq::set_platform(::CoolRun::PlatformType value) {
  assert(::CoolRun::PlatformType_IsValid(value));
  set_has_platform();
  platform_ = value;
}

// optional string account = 2;
inline bool RegistReq::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistReq::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& RegistReq::account() const {
  return *account_;
}
inline void RegistReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RegistReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void RegistReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* RegistReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string passwd = 3;
inline bool RegistReq::has_passwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RegistReq::set_has_passwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RegistReq::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RegistReq::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& RegistReq::passwd() const {
  return *passwd_;
}
inline void RegistReq::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void RegistReq::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void RegistReq::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* RegistReq::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 4;
inline bool RegistReq::has_nickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RegistReq::set_has_nickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RegistReq::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RegistReq::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& RegistReq::nickname() const {
  return *nickname_;
}
inline void RegistReq::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RegistReq::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void RegistReq::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RegistReq::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* RegistReq::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RegistReq::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RegistRsp

// required int32 rsp_code = 1;
inline bool RegistRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RegistRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RegistRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RegistRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 RegistRsp::rsp_code() const {
  return rsp_code_;
}
inline void RegistRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// optional int32 user_id = 2;
inline bool RegistRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RegistRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RegistRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RegistRsp::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 RegistRsp::user_id() const {
  return user_id_;
}
inline void RegistRsp::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// LoginReq

// required int32 user_id = 1;
inline bool LoginReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 LoginReq::user_id() const {
  return user_id_;
}
inline void LoginReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// LoginRsp

// required int32 rsp_code = 1;
inline bool LoginRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoginRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoginRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoginRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 LoginRsp::rsp_code() const {
  return rsp_code_;
}
inline void LoginRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// optional int32 new_mail = 2;
inline bool LoginRsp::has_new_mail() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoginRsp::set_has_new_mail() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoginRsp::clear_has_new_mail() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoginRsp::clear_new_mail() {
  new_mail_ = 0;
  clear_has_new_mail();
}
inline ::google::protobuf::int32 LoginRsp::new_mail() const {
  return new_mail_;
}
inline void LoginRsp::set_new_mail(::google::protobuf::int32 value) {
  set_has_new_mail();
  new_mail_ = value;
}

// optional int32 last_group = 3;
inline bool LoginRsp::has_last_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoginRsp::set_has_last_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoginRsp::clear_has_last_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoginRsp::clear_last_group() {
  last_group_ = 0;
  clear_has_last_group();
}
inline ::google::protobuf::int32 LoginRsp::last_group() const {
  return last_group_;
}
inline void LoginRsp::set_last_group(::google::protobuf::int32 value) {
  set_has_last_group();
  last_group_ = value;
}

// optional int32 last_order = 4;
inline bool LoginRsp::has_last_order() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoginRsp::set_has_last_order() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoginRsp::clear_has_last_order() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoginRsp::clear_last_order() {
  last_order_ = 0;
  clear_has_last_order();
}
inline ::google::protobuf::int32 LoginRsp::last_order() const {
  return last_order_;
}
inline void LoginRsp::set_last_order(::google::protobuf::int32 value) {
  set_has_last_order();
  last_order_ = value;
}

// -------------------------------------------------------------------

// AlterInfoReq

// required int32 user_id = 1;
inline bool AlterInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlterInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlterInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlterInfoReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 AlterInfoReq::user_id() const {
  return user_id_;
}
inline void AlterInfoReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// optional string nickname = 2;
inline bool AlterInfoReq::has_nickname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AlterInfoReq::set_has_nickname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AlterInfoReq::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AlterInfoReq::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& AlterInfoReq::nickname() const {
  return *nickname_;
}
inline void AlterInfoReq::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void AlterInfoReq::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void AlterInfoReq::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AlterInfoReq::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* AlterInfoReq::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AlterInfoReq::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AlterInfoRsp

// required int32 rsp_code = 1;
inline bool AlterInfoRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AlterInfoRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AlterInfoRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AlterInfoRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 AlterInfoRsp::rsp_code() const {
  return rsp_code_;
}
inline void AlterInfoRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// -------------------------------------------------------------------

// UnitInfo

// required int32 type = 1;
inline bool UnitInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnitInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnitInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnitInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 UnitInfo::type() const {
  return type_;
}
inline void UnitInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required bool is_activate = 2;
inline bool UnitInfo::has_is_activate() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnitInfo::set_has_is_activate() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnitInfo::clear_has_is_activate() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnitInfo::clear_is_activate() {
  is_activate_ = false;
  clear_has_is_activate();
}
inline bool UnitInfo::is_activate() const {
  return is_activate_;
}
inline void UnitInfo::set_is_activate(bool value) {
  set_has_is_activate();
  is_activate_ = value;
}

// required bool is_use = 3;
inline bool UnitInfo::has_is_use() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnitInfo::set_has_is_use() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnitInfo::clear_has_is_use() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnitInfo::clear_is_use() {
  is_use_ = false;
  clear_has_is_use();
}
inline bool UnitInfo::is_use() const {
  return is_use_;
}
inline void UnitInfo::set_is_use(bool value) {
  set_has_is_use();
  is_use_ = value;
}

// optional int32 level = 4;
inline bool UnitInfo::has_level() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void UnitInfo::set_has_level() {
  _has_bits_[0] |= 0x00000008u;
}
inline void UnitInfo::clear_has_level() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void UnitInfo::clear_level() {
  level_ = 0;
  clear_has_level();
}
inline ::google::protobuf::int32 UnitInfo::level() const {
  return level_;
}
inline void UnitInfo::set_level(::google::protobuf::int32 value) {
  set_has_level();
  level_ = value;
}

// -------------------------------------------------------------------

// UpdateInfoReq

// required int32 user_id = 1;
inline bool UpdateInfoReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateInfoReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateInfoReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateInfoReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 UpdateInfoReq::user_id() const {
  return user_id_;
}
inline void UpdateInfoReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 score = 2;
inline bool UpdateInfoReq::has_score() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UpdateInfoReq::set_has_score() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UpdateInfoReq::clear_has_score() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UpdateInfoReq::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 UpdateInfoReq::score() const {
  return score_;
}
inline void UpdateInfoReq::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// required int32 distance = 3;
inline bool UpdateInfoReq::has_distance() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UpdateInfoReq::set_has_distance() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UpdateInfoReq::clear_has_distance() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UpdateInfoReq::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline ::google::protobuf::int32 UpdateInfoReq::distance() const {
  return distance_;
}
inline void UpdateInfoReq::set_distance(::google::protobuf::int32 value) {
  set_has_distance();
  distance_ = value;
}

// repeated .CoolRun.UnitInfo actor = 4;
inline int UpdateInfoReq::actor_size() const {
  return actor_.size();
}
inline void UpdateInfoReq::clear_actor() {
  actor_.Clear();
}
inline const ::CoolRun::UnitInfo& UpdateInfoReq::actor(int index) const {
  return actor_.Get(index);
}
inline ::CoolRun::UnitInfo* UpdateInfoReq::mutable_actor(int index) {
  return actor_.Mutable(index);
}
inline ::CoolRun::UnitInfo* UpdateInfoReq::add_actor() {
  return actor_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >&
UpdateInfoReq::actor() const {
  return actor_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >*
UpdateInfoReq::mutable_actor() {
  return &actor_;
}

// repeated .CoolRun.UnitInfo pet = 5;
inline int UpdateInfoReq::pet_size() const {
  return pet_.size();
}
inline void UpdateInfoReq::clear_pet() {
  pet_.Clear();
}
inline const ::CoolRun::UnitInfo& UpdateInfoReq::pet(int index) const {
  return pet_.Get(index);
}
inline ::CoolRun::UnitInfo* UpdateInfoReq::mutable_pet(int index) {
  return pet_.Mutable(index);
}
inline ::CoolRun::UnitInfo* UpdateInfoReq::add_pet() {
  return pet_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >&
UpdateInfoReq::pet() const {
  return pet_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >*
UpdateInfoReq::mutable_pet() {
  return &pet_;
}

// repeated .CoolRun.UnitInfo magic = 6;
inline int UpdateInfoReq::magic_size() const {
  return magic_.size();
}
inline void UpdateInfoReq::clear_magic() {
  magic_.Clear();
}
inline const ::CoolRun::UnitInfo& UpdateInfoReq::magic(int index) const {
  return magic_.Get(index);
}
inline ::CoolRun::UnitInfo* UpdateInfoReq::mutable_magic(int index) {
  return magic_.Mutable(index);
}
inline ::CoolRun::UnitInfo* UpdateInfoReq::add_magic() {
  return magic_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >&
UpdateInfoReq::magic() const {
  return magic_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::UnitInfo >*
UpdateInfoReq::mutable_magic() {
  return &magic_;
}

// -------------------------------------------------------------------

// UpdateInfoRsp

// required int32 rsp_code = 1;
inline bool UpdateInfoRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UpdateInfoRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UpdateInfoRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UpdateInfoRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 UpdateInfoRsp::rsp_code() const {
  return rsp_code_;
}
inline void UpdateInfoRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// -------------------------------------------------------------------

// ItemInfo

// required int32 type = 1;
inline bool ItemInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ItemInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ItemInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ItemInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ItemInfo::type() const {
  return type_;
}
inline void ItemInfo::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// required int32 count = 2;
inline bool ItemInfo::has_count() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ItemInfo::set_has_count() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ItemInfo::clear_has_count() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ItemInfo::clear_count() {
  count_ = 0;
  clear_has_count();
}
inline ::google::protobuf::int32 ItemInfo::count() const {
  return count_;
}
inline void ItemInfo::set_count(::google::protobuf::int32 value) {
  set_has_count();
  count_ = value;
}

// -------------------------------------------------------------------

// AttachInfo

// repeated .CoolRun.ItemInfo item = 1;
inline int AttachInfo::item_size() const {
  return item_.size();
}
inline void AttachInfo::clear_item() {
  item_.Clear();
}
inline const ::CoolRun::ItemInfo& AttachInfo::item(int index) const {
  return item_.Get(index);
}
inline ::CoolRun::ItemInfo* AttachInfo::mutable_item(int index) {
  return item_.Mutable(index);
}
inline ::CoolRun::ItemInfo* AttachInfo::add_item() {
  return item_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::ItemInfo >&
AttachInfo::item() const {
  return item_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::ItemInfo >*
AttachInfo::mutable_item() {
  return &item_;
}

// optional int32 vitality = 2;
inline bool AttachInfo::has_vitality() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AttachInfo::set_has_vitality() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AttachInfo::clear_has_vitality() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AttachInfo::clear_vitality() {
  vitality_ = 0;
  clear_has_vitality();
}
inline ::google::protobuf::int32 AttachInfo::vitality() const {
  return vitality_;
}
inline void AttachInfo::set_vitality(::google::protobuf::int32 value) {
  set_has_vitality();
  vitality_ = value;
}

// -------------------------------------------------------------------

// MailInfo

// required .CoolRun.MailType type = 1;
inline bool MailInfo::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void MailInfo::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void MailInfo::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void MailInfo::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::CoolRun::MailType MailInfo::type() const {
  return static_cast< ::CoolRun::MailType >(type_);
}
inline void MailInfo::set_type(::CoolRun::MailType value) {
  assert(::CoolRun::MailType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required bool is_read = 2;
inline bool MailInfo::has_is_read() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void MailInfo::set_has_is_read() {
  _has_bits_[0] |= 0x00000002u;
}
inline void MailInfo::clear_has_is_read() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void MailInfo::clear_is_read() {
  is_read_ = false;
  clear_has_is_read();
}
inline bool MailInfo::is_read() const {
  return is_read_;
}
inline void MailInfo::set_is_read(bool value) {
  set_has_is_read();
  is_read_ = value;
}

// required int32 id = 3;
inline bool MailInfo::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void MailInfo::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void MailInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void MailInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 MailInfo::id() const {
  return id_;
}
inline void MailInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required int32 addresser_id = 4;
inline bool MailInfo::has_addresser_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void MailInfo::set_has_addresser_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void MailInfo::clear_has_addresser_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void MailInfo::clear_addresser_id() {
  addresser_id_ = 0;
  clear_has_addresser_id();
}
inline ::google::protobuf::int32 MailInfo::addresser_id() const {
  return addresser_id_;
}
inline void MailInfo::set_addresser_id(::google::protobuf::int32 value) {
  set_has_addresser_id();
  addresser_id_ = value;
}

// optional .CoolRun.AttachInfo attach = 5;
inline bool MailInfo::has_attach() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void MailInfo::set_has_attach() {
  _has_bits_[0] |= 0x00000010u;
}
inline void MailInfo::clear_has_attach() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void MailInfo::clear_attach() {
  if (attach_ != NULL) attach_->::CoolRun::AttachInfo::Clear();
  clear_has_attach();
}
inline const ::CoolRun::AttachInfo& MailInfo::attach() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attach_ != NULL ? *attach_ : *default_instance().attach_;
#else
  return attach_ != NULL ? *attach_ : *default_instance_->attach_;
#endif
}
inline ::CoolRun::AttachInfo* MailInfo::mutable_attach() {
  set_has_attach();
  if (attach_ == NULL) attach_ = new ::CoolRun::AttachInfo;
  return attach_;
}
inline ::CoolRun::AttachInfo* MailInfo::release_attach() {
  clear_has_attach();
  ::CoolRun::AttachInfo* temp = attach_;
  attach_ = NULL;
  return temp;
}
inline void MailInfo::set_allocated_attach(::CoolRun::AttachInfo* attach) {
  delete attach_;
  attach_ = attach;
  if (attach) {
    set_has_attach();
  } else {
    clear_has_attach();
  }
}

// optional string addresser = 6;
inline bool MailInfo::has_addresser() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void MailInfo::set_has_addresser() {
  _has_bits_[0] |= 0x00000020u;
}
inline void MailInfo::clear_has_addresser() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void MailInfo::clear_addresser() {
  if (addresser_ != &::google::protobuf::internal::kEmptyString) {
    addresser_->clear();
  }
  clear_has_addresser();
}
inline const ::std::string& MailInfo::addresser() const {
  return *addresser_;
}
inline void MailInfo::set_addresser(const ::std::string& value) {
  set_has_addresser();
  if (addresser_ == &::google::protobuf::internal::kEmptyString) {
    addresser_ = new ::std::string;
  }
  addresser_->assign(value);
}
inline void MailInfo::set_addresser(const char* value) {
  set_has_addresser();
  if (addresser_ == &::google::protobuf::internal::kEmptyString) {
    addresser_ = new ::std::string;
  }
  addresser_->assign(value);
}
inline void MailInfo::set_addresser(const char* value, size_t size) {
  set_has_addresser();
  if (addresser_ == &::google::protobuf::internal::kEmptyString) {
    addresser_ = new ::std::string;
  }
  addresser_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MailInfo::mutable_addresser() {
  set_has_addresser();
  if (addresser_ == &::google::protobuf::internal::kEmptyString) {
    addresser_ = new ::std::string;
  }
  return addresser_;
}
inline ::std::string* MailInfo::release_addresser() {
  clear_has_addresser();
  if (addresser_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = addresser_;
    addresser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MailInfo::set_allocated_addresser(::std::string* addresser) {
  if (addresser_ != &::google::protobuf::internal::kEmptyString) {
    delete addresser_;
  }
  if (addresser) {
    set_has_addresser();
    addresser_ = addresser;
  } else {
    clear_has_addresser();
    addresser_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string content = 7;
inline bool MailInfo::has_content() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void MailInfo::set_has_content() {
  _has_bits_[0] |= 0x00000040u;
}
inline void MailInfo::clear_has_content() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void MailInfo::clear_content() {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    content_->clear();
  }
  clear_has_content();
}
inline const ::std::string& MailInfo::content() const {
  return *content_;
}
inline void MailInfo::set_content(const ::std::string& value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MailInfo::set_content(const char* value) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(value);
}
inline void MailInfo::set_content(const char* value, size_t size) {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  content_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* MailInfo::mutable_content() {
  set_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    content_ = new ::std::string;
  }
  return content_;
}
inline ::std::string* MailInfo::release_content() {
  clear_has_content();
  if (content_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = content_;
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void MailInfo::set_allocated_content(::std::string* content) {
  if (content_ != &::google::protobuf::internal::kEmptyString) {
    delete content_;
  }
  if (content) {
    set_has_content();
    content_ = content;
  } else {
    clear_has_content();
    content_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryMailReq

// required int32 user_id = 1;
inline bool QueryMailReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryMailReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryMailReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryMailReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 QueryMailReq::user_id() const {
  return user_id_;
}
inline void QueryMailReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// QueryMailRsp

// required int32 rsp_code = 1;
inline bool QueryMailRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryMailRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryMailRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryMailRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 QueryMailRsp::rsp_code() const {
  return rsp_code_;
}
inline void QueryMailRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// repeated .CoolRun.MailInfo email = 2;
inline int QueryMailRsp::email_size() const {
  return email_.size();
}
inline void QueryMailRsp::clear_email() {
  email_.Clear();
}
inline const ::CoolRun::MailInfo& QueryMailRsp::email(int index) const {
  return email_.Get(index);
}
inline ::CoolRun::MailInfo* QueryMailRsp::mutable_email(int index) {
  return email_.Mutable(index);
}
inline ::CoolRun::MailInfo* QueryMailRsp::add_email() {
  return email_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::MailInfo >&
QueryMailRsp::email() const {
  return email_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::MailInfo >*
QueryMailRsp::mutable_email() {
  return &email_;
}

// -------------------------------------------------------------------

// ReadMailReq

// required int32 user_id = 1;
inline bool ReadMailReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadMailReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadMailReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadMailReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 ReadMailReq::user_id() const {
  return user_id_;
}
inline void ReadMailReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 id = 2;
inline bool ReadMailReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ReadMailReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ReadMailReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ReadMailReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 ReadMailReq::id() const {
  return id_;
}
inline void ReadMailReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// ReadMailRsp

// required int32 rsp_code = 1;
inline bool ReadMailRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReadMailRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReadMailRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReadMailRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 ReadMailRsp::rsp_code() const {
  return rsp_code_;
}
inline void ReadMailRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// -------------------------------------------------------------------

// RankBonusInfo

// required int32 id = 1;
inline bool RankBonusInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RankBonusInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RankBonusInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RankBonusInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RankBonusInfo::id() const {
  return id_;
}
inline void RankBonusInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional int32 group_id = 2;
inline bool RankBonusInfo::has_group_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankBonusInfo::set_has_group_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankBonusInfo::clear_has_group_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankBonusInfo::clear_group_id() {
  group_id_ = 0;
  clear_has_group_id();
}
inline ::google::protobuf::int32 RankBonusInfo::group_id() const {
  return group_id_;
}
inline void RankBonusInfo::set_group_id(::google::protobuf::int32 value) {
  set_has_group_id();
  group_id_ = value;
}

// optional string group_name = 3;
inline bool RankBonusInfo::has_group_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RankBonusInfo::set_has_group_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RankBonusInfo::clear_has_group_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RankBonusInfo::clear_group_name() {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    group_name_->clear();
  }
  clear_has_group_name();
}
inline const ::std::string& RankBonusInfo::group_name() const {
  return *group_name_;
}
inline void RankBonusInfo::set_group_name(const ::std::string& value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void RankBonusInfo::set_group_name(const char* value) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(value);
}
inline void RankBonusInfo::set_group_name(const char* value, size_t size) {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  group_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RankBonusInfo::mutable_group_name() {
  set_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    group_name_ = new ::std::string;
  }
  return group_name_;
}
inline ::std::string* RankBonusInfo::release_group_name() {
  clear_has_group_name();
  if (group_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = group_name_;
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RankBonusInfo::set_allocated_group_name(::std::string* group_name) {
  if (group_name_ != &::google::protobuf::internal::kEmptyString) {
    delete group_name_;
  }
  if (group_name) {
    set_has_group_name();
    group_name_ = group_name;
  } else {
    clear_has_group_name();
    group_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 bonus_id = 4;
inline bool RankBonusInfo::has_bonus_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RankBonusInfo::set_has_bonus_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RankBonusInfo::clear_has_bonus_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RankBonusInfo::clear_bonus_id() {
  bonus_id_ = 0;
  clear_has_bonus_id();
}
inline ::google::protobuf::int32 RankBonusInfo::bonus_id() const {
  return bonus_id_;
}
inline void RankBonusInfo::set_bonus_id(::google::protobuf::int32 value) {
  set_has_bonus_id();
  bonus_id_ = value;
}

// optional .CoolRun.AttachInfo attach = 5;
inline bool RankBonusInfo::has_attach() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RankBonusInfo::set_has_attach() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RankBonusInfo::clear_has_attach() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RankBonusInfo::clear_attach() {
  if (attach_ != NULL) attach_->::CoolRun::AttachInfo::Clear();
  clear_has_attach();
}
inline const ::CoolRun::AttachInfo& RankBonusInfo::attach() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attach_ != NULL ? *attach_ : *default_instance().attach_;
#else
  return attach_ != NULL ? *attach_ : *default_instance_->attach_;
#endif
}
inline ::CoolRun::AttachInfo* RankBonusInfo::mutable_attach() {
  set_has_attach();
  if (attach_ == NULL) attach_ = new ::CoolRun::AttachInfo;
  return attach_;
}
inline ::CoolRun::AttachInfo* RankBonusInfo::release_attach() {
  clear_has_attach();
  ::CoolRun::AttachInfo* temp = attach_;
  attach_ = NULL;
  return temp;
}
inline void RankBonusInfo::set_allocated_attach(::CoolRun::AttachInfo* attach) {
  delete attach_;
  attach_ = attach;
  if (attach) {
    set_has_attach();
  } else {
    clear_has_attach();
  }
}

// -------------------------------------------------------------------

// RankUserInfo

// required int32 user_id = 1;
inline bool RankUserInfo::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RankUserInfo::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RankUserInfo::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RankUserInfo::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 RankUserInfo::user_id() const {
  return user_id_;
}
inline void RankUserInfo::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 user_order = 2;
inline bool RankUserInfo::has_user_order() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RankUserInfo::set_has_user_order() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RankUserInfo::clear_has_user_order() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RankUserInfo::clear_user_order() {
  user_order_ = 0;
  clear_has_user_order();
}
inline ::google::protobuf::int32 RankUserInfo::user_order() const {
  return user_order_;
}
inline void RankUserInfo::set_user_order(::google::protobuf::int32 value) {
  set_has_user_order();
  user_order_ = value;
}

// required int32 score = 3;
inline bool RankUserInfo::has_score() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RankUserInfo::set_has_score() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RankUserInfo::clear_has_score() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RankUserInfo::clear_score() {
  score_ = 0;
  clear_has_score();
}
inline ::google::protobuf::int32 RankUserInfo::score() const {
  return score_;
}
inline void RankUserInfo::set_score(::google::protobuf::int32 value) {
  set_has_score();
  score_ = value;
}

// required int32 distance = 4;
inline bool RankUserInfo::has_distance() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RankUserInfo::set_has_distance() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RankUserInfo::clear_has_distance() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RankUserInfo::clear_distance() {
  distance_ = 0;
  clear_has_distance();
}
inline ::google::protobuf::int32 RankUserInfo::distance() const {
  return distance_;
}
inline void RankUserInfo::set_distance(::google::protobuf::int32 value) {
  set_has_distance();
  distance_ = value;
}

// required .CoolRun.UnitInfo actor = 5;
inline bool RankUserInfo::has_actor() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void RankUserInfo::set_has_actor() {
  _has_bits_[0] |= 0x00000010u;
}
inline void RankUserInfo::clear_has_actor() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void RankUserInfo::clear_actor() {
  if (actor_ != NULL) actor_->::CoolRun::UnitInfo::Clear();
  clear_has_actor();
}
inline const ::CoolRun::UnitInfo& RankUserInfo::actor() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return actor_ != NULL ? *actor_ : *default_instance().actor_;
#else
  return actor_ != NULL ? *actor_ : *default_instance_->actor_;
#endif
}
inline ::CoolRun::UnitInfo* RankUserInfo::mutable_actor() {
  set_has_actor();
  if (actor_ == NULL) actor_ = new ::CoolRun::UnitInfo;
  return actor_;
}
inline ::CoolRun::UnitInfo* RankUserInfo::release_actor() {
  clear_has_actor();
  ::CoolRun::UnitInfo* temp = actor_;
  actor_ = NULL;
  return temp;
}
inline void RankUserInfo::set_allocated_actor(::CoolRun::UnitInfo* actor) {
  delete actor_;
  actor_ = actor;
  if (actor) {
    set_has_actor();
  } else {
    clear_has_actor();
  }
}

// optional .CoolRun.UnitInfo pet = 6;
inline bool RankUserInfo::has_pet() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void RankUserInfo::set_has_pet() {
  _has_bits_[0] |= 0x00000020u;
}
inline void RankUserInfo::clear_has_pet() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void RankUserInfo::clear_pet() {
  if (pet_ != NULL) pet_->::CoolRun::UnitInfo::Clear();
  clear_has_pet();
}
inline const ::CoolRun::UnitInfo& RankUserInfo::pet() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pet_ != NULL ? *pet_ : *default_instance().pet_;
#else
  return pet_ != NULL ? *pet_ : *default_instance_->pet_;
#endif
}
inline ::CoolRun::UnitInfo* RankUserInfo::mutable_pet() {
  set_has_pet();
  if (pet_ == NULL) pet_ = new ::CoolRun::UnitInfo;
  return pet_;
}
inline ::CoolRun::UnitInfo* RankUserInfo::release_pet() {
  clear_has_pet();
  ::CoolRun::UnitInfo* temp = pet_;
  pet_ = NULL;
  return temp;
}
inline void RankUserInfo::set_allocated_pet(::CoolRun::UnitInfo* pet) {
  delete pet_;
  pet_ = pet;
  if (pet) {
    set_has_pet();
  } else {
    clear_has_pet();
  }
}

// optional .CoolRun.UnitInfo magic = 7;
inline bool RankUserInfo::has_magic() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void RankUserInfo::set_has_magic() {
  _has_bits_[0] |= 0x00000040u;
}
inline void RankUserInfo::clear_has_magic() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void RankUserInfo::clear_magic() {
  if (magic_ != NULL) magic_->::CoolRun::UnitInfo::Clear();
  clear_has_magic();
}
inline const ::CoolRun::UnitInfo& RankUserInfo::magic() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return magic_ != NULL ? *magic_ : *default_instance().magic_;
#else
  return magic_ != NULL ? *magic_ : *default_instance_->magic_;
#endif
}
inline ::CoolRun::UnitInfo* RankUserInfo::mutable_magic() {
  set_has_magic();
  if (magic_ == NULL) magic_ = new ::CoolRun::UnitInfo;
  return magic_;
}
inline ::CoolRun::UnitInfo* RankUserInfo::release_magic() {
  clear_has_magic();
  ::CoolRun::UnitInfo* temp = magic_;
  magic_ = NULL;
  return temp;
}
inline void RankUserInfo::set_allocated_magic(::CoolRun::UnitInfo* magic) {
  delete magic_;
  magic_ = magic;
  if (magic) {
    set_has_magic();
  } else {
    clear_has_magic();
  }
}

// optional string user_name = 8;
inline bool RankUserInfo::has_user_name() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void RankUserInfo::set_has_user_name() {
  _has_bits_[0] |= 0x00000080u;
}
inline void RankUserInfo::clear_has_user_name() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void RankUserInfo::clear_user_name() {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    user_name_->clear();
  }
  clear_has_user_name();
}
inline const ::std::string& RankUserInfo::user_name() const {
  return *user_name_;
}
inline void RankUserInfo::set_user_name(const ::std::string& value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void RankUserInfo::set_user_name(const char* value) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(value);
}
inline void RankUserInfo::set_user_name(const char* value, size_t size) {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  user_name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RankUserInfo::mutable_user_name() {
  set_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    user_name_ = new ::std::string;
  }
  return user_name_;
}
inline ::std::string* RankUserInfo::release_user_name() {
  clear_has_user_name();
  if (user_name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = user_name_;
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RankUserInfo::set_allocated_user_name(::std::string* user_name) {
  if (user_name_ != &::google::protobuf::internal::kEmptyString) {
    delete user_name_;
  }
  if (user_name) {
    set_has_user_name();
    user_name_ = user_name;
  } else {
    clear_has_user_name();
    user_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryRankBonusReq

// required int32 stub = 1;
inline bool QueryRankBonusReq::has_stub() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryRankBonusReq::set_has_stub() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryRankBonusReq::clear_has_stub() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryRankBonusReq::clear_stub() {
  stub_ = 0;
  clear_has_stub();
}
inline ::google::protobuf::int32 QueryRankBonusReq::stub() const {
  return stub_;
}
inline void QueryRankBonusReq::set_stub(::google::protobuf::int32 value) {
  set_has_stub();
  stub_ = value;
}

// -------------------------------------------------------------------

// QueryRankBonusRsp

// required int32 rsp_code = 1;
inline bool QueryRankBonusRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryRankBonusRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryRankBonusRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryRankBonusRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 QueryRankBonusRsp::rsp_code() const {
  return rsp_code_;
}
inline void QueryRankBonusRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// repeated .CoolRun.RankBonusInfo bonus = 2;
inline int QueryRankBonusRsp::bonus_size() const {
  return bonus_.size();
}
inline void QueryRankBonusRsp::clear_bonus() {
  bonus_.Clear();
}
inline const ::CoolRun::RankBonusInfo& QueryRankBonusRsp::bonus(int index) const {
  return bonus_.Get(index);
}
inline ::CoolRun::RankBonusInfo* QueryRankBonusRsp::mutable_bonus(int index) {
  return bonus_.Mutable(index);
}
inline ::CoolRun::RankBonusInfo* QueryRankBonusRsp::add_bonus() {
  return bonus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::RankBonusInfo >&
QueryRankBonusRsp::bonus() const {
  return bonus_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::RankBonusInfo >*
QueryRankBonusRsp::mutable_bonus() {
  return &bonus_;
}

// -------------------------------------------------------------------

// QueryRankListReq

// required int32 user_id = 1;
inline bool QueryRankListReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryRankListReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryRankListReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryRankListReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 QueryRankListReq::user_id() const {
  return user_id_;
}
inline void QueryRankListReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// QueryRankListRsp

// required int32 rsp_code = 1;
inline bool QueryRankListRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryRankListRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryRankListRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryRankListRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 QueryRankListRsp::rsp_code() const {
  return rsp_code_;
}
inline void QueryRankListRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// repeated .CoolRun.RankUserInfo user_list = 2;
inline int QueryRankListRsp::user_list_size() const {
  return user_list_.size();
}
inline void QueryRankListRsp::clear_user_list() {
  user_list_.Clear();
}
inline const ::CoolRun::RankUserInfo& QueryRankListRsp::user_list(int index) const {
  return user_list_.Get(index);
}
inline ::CoolRun::RankUserInfo* QueryRankListRsp::mutable_user_list(int index) {
  return user_list_.Mutable(index);
}
inline ::CoolRun::RankUserInfo* QueryRankListRsp::add_user_list() {
  return user_list_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::RankUserInfo >&
QueryRankListRsp::user_list() const {
  return user_list_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::RankUserInfo >*
QueryRankListRsp::mutable_user_list() {
  return &user_list_;
}

// optional int32 cur_group = 3;
inline bool QueryRankListRsp::has_cur_group() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryRankListRsp::set_has_cur_group() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryRankListRsp::clear_has_cur_group() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryRankListRsp::clear_cur_group() {
  cur_group_ = 0;
  clear_has_cur_group();
}
inline ::google::protobuf::int32 QueryRankListRsp::cur_group() const {
  return cur_group_;
}
inline void QueryRankListRsp::set_cur_group(::google::protobuf::int32 value) {
  set_has_cur_group();
  cur_group_ = value;
}

// -------------------------------------------------------------------

// BonusInfo

// required int32 id = 1;
inline bool BonusInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BonusInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void BonusInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void BonusInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 BonusInfo::id() const {
  return id_;
}
inline void BonusInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required bool is_get = 2;
inline bool BonusInfo::has_is_get() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void BonusInfo::set_has_is_get() {
  _has_bits_[0] |= 0x00000002u;
}
inline void BonusInfo::clear_has_is_get() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void BonusInfo::clear_is_get() {
  is_get_ = false;
  clear_has_is_get();
}
inline bool BonusInfo::is_get() const {
  return is_get_;
}
inline void BonusInfo::set_is_get(bool value) {
  set_has_is_get();
  is_get_ = value;
}

// required bool enable = 3;
inline bool BonusInfo::has_enable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void BonusInfo::set_has_enable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void BonusInfo::clear_has_enable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void BonusInfo::clear_enable() {
  enable_ = false;
  clear_has_enable();
}
inline bool BonusInfo::enable() const {
  return enable_;
}
inline void BonusInfo::set_enable(bool value) {
  set_has_enable();
  enable_ = value;
}

// optional .CoolRun.AttachInfo attach = 4;
inline bool BonusInfo::has_attach() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void BonusInfo::set_has_attach() {
  _has_bits_[0] |= 0x00000008u;
}
inline void BonusInfo::clear_has_attach() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void BonusInfo::clear_attach() {
  if (attach_ != NULL) attach_->::CoolRun::AttachInfo::Clear();
  clear_has_attach();
}
inline const ::CoolRun::AttachInfo& BonusInfo::attach() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attach_ != NULL ? *attach_ : *default_instance().attach_;
#else
  return attach_ != NULL ? *attach_ : *default_instance_->attach_;
#endif
}
inline ::CoolRun::AttachInfo* BonusInfo::mutable_attach() {
  set_has_attach();
  if (attach_ == NULL) attach_ = new ::CoolRun::AttachInfo;
  return attach_;
}
inline ::CoolRun::AttachInfo* BonusInfo::release_attach() {
  clear_has_attach();
  ::CoolRun::AttachInfo* temp = attach_;
  attach_ = NULL;
  return temp;
}
inline void BonusInfo::set_allocated_attach(::CoolRun::AttachInfo* attach) {
  delete attach_;
  attach_ = attach;
  if (attach) {
    set_has_attach();
  } else {
    clear_has_attach();
  }
}

// -------------------------------------------------------------------

// QuerySystemBonusReq

// required int32 user_id = 1;
inline bool QuerySystemBonusReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuerySystemBonusReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuerySystemBonusReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuerySystemBonusReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 QuerySystemBonusReq::user_id() const {
  return user_id_;
}
inline void QuerySystemBonusReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// QuerySystemBonusRsp

// required int32 rsp_code = 1;
inline bool QuerySystemBonusRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QuerySystemBonusRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QuerySystemBonusRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QuerySystemBonusRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 QuerySystemBonusRsp::rsp_code() const {
  return rsp_code_;
}
inline void QuerySystemBonusRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// repeated .CoolRun.BonusInfo bonus = 2;
inline int QuerySystemBonusRsp::bonus_size() const {
  return bonus_.size();
}
inline void QuerySystemBonusRsp::clear_bonus() {
  bonus_.Clear();
}
inline const ::CoolRun::BonusInfo& QuerySystemBonusRsp::bonus(int index) const {
  return bonus_.Get(index);
}
inline ::CoolRun::BonusInfo* QuerySystemBonusRsp::mutable_bonus(int index) {
  return bonus_.Mutable(index);
}
inline ::CoolRun::BonusInfo* QuerySystemBonusRsp::add_bonus() {
  return bonus_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::BonusInfo >&
QuerySystemBonusRsp::bonus() const {
  return bonus_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::BonusInfo >*
QuerySystemBonusRsp::mutable_bonus() {
  return &bonus_;
}

// -------------------------------------------------------------------

// GetSystemBonusReq

// required int32 user_id = 1;
inline bool GetSystemBonusReq::has_user_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSystemBonusReq::set_has_user_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSystemBonusReq::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSystemBonusReq::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 GetSystemBonusReq::user_id() const {
  return user_id_;
}
inline void GetSystemBonusReq::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// required int32 id = 2;
inline bool GetSystemBonusReq::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GetSystemBonusReq::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GetSystemBonusReq::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GetSystemBonusReq::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GetSystemBonusReq::id() const {
  return id_;
}
inline void GetSystemBonusReq::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// -------------------------------------------------------------------

// GetSystemBonusRsp

// required int32 rsp_code = 1;
inline bool GetSystemBonusRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GetSystemBonusRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GetSystemBonusRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GetSystemBonusRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 GetSystemBonusRsp::rsp_code() const {
  return rsp_code_;
}
inline void GetSystemBonusRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// -------------------------------------------------------------------

// GiftBagAttach

// required int32 weight = 1;
inline bool GiftBagAttach::has_weight() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiftBagAttach::set_has_weight() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiftBagAttach::clear_has_weight() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiftBagAttach::clear_weight() {
  weight_ = 0;
  clear_has_weight();
}
inline ::google::protobuf::int32 GiftBagAttach::weight() const {
  return weight_;
}
inline void GiftBagAttach::set_weight(::google::protobuf::int32 value) {
  set_has_weight();
  weight_ = value;
}

// optional .CoolRun.AttachInfo attach = 2;
inline bool GiftBagAttach::has_attach() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GiftBagAttach::set_has_attach() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GiftBagAttach::clear_has_attach() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GiftBagAttach::clear_attach() {
  if (attach_ != NULL) attach_->::CoolRun::AttachInfo::Clear();
  clear_has_attach();
}
inline const ::CoolRun::AttachInfo& GiftBagAttach::attach() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return attach_ != NULL ? *attach_ : *default_instance().attach_;
#else
  return attach_ != NULL ? *attach_ : *default_instance_->attach_;
#endif
}
inline ::CoolRun::AttachInfo* GiftBagAttach::mutable_attach() {
  set_has_attach();
  if (attach_ == NULL) attach_ = new ::CoolRun::AttachInfo;
  return attach_;
}
inline ::CoolRun::AttachInfo* GiftBagAttach::release_attach() {
  clear_has_attach();
  ::CoolRun::AttachInfo* temp = attach_;
  attach_ = NULL;
  return temp;
}
inline void GiftBagAttach::set_allocated_attach(::CoolRun::AttachInfo* attach) {
  delete attach_;
  attach_ = attach;
  if (attach) {
    set_has_attach();
  } else {
    clear_has_attach();
  }
}

// -------------------------------------------------------------------

// GiftBagInfo

// required int32 id = 1;
inline bool GiftBagInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GiftBagInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GiftBagInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GiftBagInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 GiftBagInfo::id() const {
  return id_;
}
inline void GiftBagInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required bool is_random = 2;
inline bool GiftBagInfo::has_is_random() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GiftBagInfo::set_has_is_random() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GiftBagInfo::clear_has_is_random() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GiftBagInfo::clear_is_random() {
  is_random_ = false;
  clear_has_is_random();
}
inline bool GiftBagInfo::is_random() const {
  return is_random_;
}
inline void GiftBagInfo::set_is_random(bool value) {
  set_has_is_random();
  is_random_ = value;
}

// repeated .CoolRun.GiftBagAttach attach = 3;
inline int GiftBagInfo::attach_size() const {
  return attach_.size();
}
inline void GiftBagInfo::clear_attach() {
  attach_.Clear();
}
inline const ::CoolRun::GiftBagAttach& GiftBagInfo::attach(int index) const {
  return attach_.Get(index);
}
inline ::CoolRun::GiftBagAttach* GiftBagInfo::mutable_attach(int index) {
  return attach_.Mutable(index);
}
inline ::CoolRun::GiftBagAttach* GiftBagInfo::add_attach() {
  return attach_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagAttach >&
GiftBagInfo::attach() const {
  return attach_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagAttach >*
GiftBagInfo::mutable_attach() {
  return &attach_;
}

// -------------------------------------------------------------------

// QueryGiftBagReq

// required string version = 1;
inline bool QueryGiftBagReq::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryGiftBagReq::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryGiftBagReq::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryGiftBagReq::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& QueryGiftBagReq::version() const {
  return *version_;
}
inline void QueryGiftBagReq::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void QueryGiftBagReq::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void QueryGiftBagReq::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryGiftBagReq::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* QueryGiftBagReq::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryGiftBagReq::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// QueryGiftBagRsp

// required int32 rsp_code = 1;
inline bool QueryGiftBagRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void QueryGiftBagRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void QueryGiftBagRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void QueryGiftBagRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 QueryGiftBagRsp::rsp_code() const {
  return rsp_code_;
}
inline void QueryGiftBagRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// repeated .CoolRun.GiftBagInfo gift_bag = 2;
inline int QueryGiftBagRsp::gift_bag_size() const {
  return gift_bag_.size();
}
inline void QueryGiftBagRsp::clear_gift_bag() {
  gift_bag_.Clear();
}
inline const ::CoolRun::GiftBagInfo& QueryGiftBagRsp::gift_bag(int index) const {
  return gift_bag_.Get(index);
}
inline ::CoolRun::GiftBagInfo* QueryGiftBagRsp::mutable_gift_bag(int index) {
  return gift_bag_.Mutable(index);
}
inline ::CoolRun::GiftBagInfo* QueryGiftBagRsp::add_gift_bag() {
  return gift_bag_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagInfo >&
QueryGiftBagRsp::gift_bag() const {
  return gift_bag_;
}
inline ::google::protobuf::RepeatedPtrField< ::CoolRun::GiftBagInfo >*
QueryGiftBagRsp::mutable_gift_bag() {
  return &gift_bag_;
}

// optional bool is_update = 3;
inline bool QueryGiftBagRsp::has_is_update() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void QueryGiftBagRsp::set_has_is_update() {
  _has_bits_[0] |= 0x00000004u;
}
inline void QueryGiftBagRsp::clear_has_is_update() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void QueryGiftBagRsp::clear_is_update() {
  is_update_ = false;
  clear_has_is_update();
}
inline bool QueryGiftBagRsp::is_update() const {
  return is_update_;
}
inline void QueryGiftBagRsp::set_is_update(bool value) {
  set_has_is_update();
  is_update_ = value;
}

// optional string version = 4;
inline bool QueryGiftBagRsp::has_version() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void QueryGiftBagRsp::set_has_version() {
  _has_bits_[0] |= 0x00000008u;
}
inline void QueryGiftBagRsp::clear_has_version() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void QueryGiftBagRsp::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& QueryGiftBagRsp::version() const {
  return *version_;
}
inline void QueryGiftBagRsp::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void QueryGiftBagRsp::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void QueryGiftBagRsp::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* QueryGiftBagRsp::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* QueryGiftBagRsp::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void QueryGiftBagRsp::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UnifyReq

// required .CoolRun.PlatformType platform = 1;
inline bool UnifyReq::has_platform() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnifyReq::set_has_platform() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnifyReq::clear_has_platform() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnifyReq::clear_platform() {
  platform_ = 0;
  clear_has_platform();
}
inline ::CoolRun::PlatformType UnifyReq::platform() const {
  return static_cast< ::CoolRun::PlatformType >(platform_);
}
inline void UnifyReq::set_platform(::CoolRun::PlatformType value) {
  assert(::CoolRun::PlatformType_IsValid(value));
  set_has_platform();
  platform_ = value;
}

// optional string account = 2;
inline bool UnifyReq::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnifyReq::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnifyReq::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnifyReq::clear_account() {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    account_->clear();
  }
  clear_has_account();
}
inline const ::std::string& UnifyReq::account() const {
  return *account_;
}
inline void UnifyReq::set_account(const ::std::string& value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UnifyReq::set_account(const char* value) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(value);
}
inline void UnifyReq::set_account(const char* value, size_t size) {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  account_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnifyReq::mutable_account() {
  set_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    account_ = new ::std::string;
  }
  return account_;
}
inline ::std::string* UnifyReq::release_account() {
  clear_has_account();
  if (account_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = account_;
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnifyReq::set_allocated_account(::std::string* account) {
  if (account_ != &::google::protobuf::internal::kEmptyString) {
    delete account_;
  }
  if (account) {
    set_has_account();
    account_ = account;
  } else {
    clear_has_account();
    account_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string passwd = 3;
inline bool UnifyReq::has_passwd() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void UnifyReq::set_has_passwd() {
  _has_bits_[0] |= 0x00000004u;
}
inline void UnifyReq::clear_has_passwd() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void UnifyReq::clear_passwd() {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    passwd_->clear();
  }
  clear_has_passwd();
}
inline const ::std::string& UnifyReq::passwd() const {
  return *passwd_;
}
inline void UnifyReq::set_passwd(const ::std::string& value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UnifyReq::set_passwd(const char* value) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(value);
}
inline void UnifyReq::set_passwd(const char* value, size_t size) {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  passwd_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* UnifyReq::mutable_passwd() {
  set_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    passwd_ = new ::std::string;
  }
  return passwd_;
}
inline ::std::string* UnifyReq::release_passwd() {
  clear_has_passwd();
  if (passwd_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwd_;
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void UnifyReq::set_allocated_passwd(::std::string* passwd) {
  if (passwd_ != &::google::protobuf::internal::kEmptyString) {
    delete passwd_;
  }
  if (passwd) {
    set_has_passwd();
    passwd_ = passwd;
  } else {
    clear_has_passwd();
    passwd_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// UnifyRsp

// required int32 rsp_code = 1;
inline bool UnifyRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void UnifyRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void UnifyRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void UnifyRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 UnifyRsp::rsp_code() const {
  return rsp_code_;
}
inline void UnifyRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}

// optional int32 user_id = 2;
inline bool UnifyRsp::has_user_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void UnifyRsp::set_has_user_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void UnifyRsp::clear_has_user_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void UnifyRsp::clear_user_id() {
  user_id_ = 0;
  clear_has_user_id();
}
inline ::google::protobuf::int32 UnifyRsp::user_id() const {
  return user_id_;
}
inline void UnifyRsp::set_user_id(::google::protobuf::int32 value) {
  set_has_user_id();
  user_id_ = value;
}

// -------------------------------------------------------------------

// ReconfigureReq

// required int32 type = 1;
inline bool ReconfigureReq::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReconfigureReq::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReconfigureReq::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReconfigureReq::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 ReconfigureReq::type() const {
  return type_;
}
inline void ReconfigureReq::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// -------------------------------------------------------------------

// ReconfigureRsp

// required int32 rsp_code = 1;
inline bool ReconfigureRsp::has_rsp_code() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ReconfigureRsp::set_has_rsp_code() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ReconfigureRsp::clear_has_rsp_code() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ReconfigureRsp::clear_rsp_code() {
  rsp_code_ = 0;
  clear_has_rsp_code();
}
inline ::google::protobuf::int32 ReconfigureRsp::rsp_code() const {
  return rsp_code_;
}
inline void ReconfigureRsp::set_rsp_code(::google::protobuf::int32 value) {
  set_has_rsp_code();
  rsp_code_ = value;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace CoolRun

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_protocol_5fmessage_2eproto__INCLUDED
